
# SLAM 14讲 高翔


# 1 - 3 章 简单回顾

## 第一章 

SLAM的两个主要问题， 1. 明白自身的状态（位置）， 2. 了解外在的环境 （建图）。
可以通过两类方式来实现： 一是通过携带于机器人本体上的传感器；而是通过安装于环境当中的标志。

==单目相机==： 通过二维信息记录了世界，但是损失了深度信息。但是可以通过相机的移动来确定物体得视差，然后来判断物体的**远近**，但是因为这个远近只是一个相对值，所以缺少一个尺度因子，单目图像无法确定这个真实尺度，又称为**尺度不确定性**。
==双目相机==：在单目相机的基础上，通过双目生成的**视差图**来对深度进行计算，但是他计算出来的结果也不是很准确的，同时双目相机能探测到的深度范围和基线相关，基线越大能测量到的物体就越远，同时他的计算量也比较大， 需要使用GPU或者FPGA设备进行加速，目前**计算量**是双目的主要问题之一。
==深度相机==： 也叫RGB-D相机，通过物理测量的手段，相比于双目相机节省了大量的计算资源。但是还存在测量范围窄、噪声大、视野小、易受日光干扰等因素，目前**主要用于室内**，室外较难应用。

#### 经典视觉SLAM框架

1. 传感器信息获取： 视觉SLAM中主要表现为相机图像的信息的读取和预处理。
2. 前端视觉里程计（Visual Odometry VO）：用于估计相邻图像间相机的运动，以及局部地图的样子。 VO 也被称为前端。
3. 后端非线性优化（Optimization） ： 对不同时刻的视觉里程计测量的相机位姿和回环信息进行优化，得到全局一致的轨迹和地图。
4. 回环检测 （Loop Closure Detection）：回环检测判断机器人是否到达过先前的位置， 如果检测到回环，会把信息给后端进行处理。
5. 建图（Mapping）： 根据估计的轨迹， 建立与任务要求对应的地图。包括度量地图和拓扑地图，两种。

==在视觉SLAM中， 前端和计算机视觉研究领域更为相关，比如图像的特征提取与匹配等，后端则主要是滤波与非线性优化算法。==

### 三维钢体运动

####  描述三维运动 （欧式变换）
1. 旋转矩阵： 3 * 3 的单位正交阵，9个量表述了3个自由度。
2. 旋转向量：用一个旋转轴和旋转角来描述， 向量的方向和旋转轴方向一致，长度等于旋转角。从旋转向量转为旋转矩阵，可以通过罗德里格斯公式来计算：
 单位长度的向量为 $n$ , 旋转的角度为$\theta$.
 则 旋转矩阵$R$   = $cos\theta I + (1 - cos\theta)n n^T + sin\theta n^{反对称}$。
 从旋转矩阵到旋转向量也可以进行转换。
3. 欧拉角： 使用三个角度（yaw 偏航角 pitch 俯仰角 roll 滚转角）来描述。
4. 四元数： 因为旋转矩阵有冗余性，旋转向量和欧拉角有奇异性，通过四元数来描述，是复数域中的定义。使用前需要归一化。
#### 相似、仿射、射影变换
![[1-3 figure1.png]]

# 第4章 李群与李代数 （不会，略）
简单来说就是 ，李代数可以求导，而且是连续的，所以在优化的时候可以更好的通过数学方法来
# 第5章 相机与图像

### 针孔相机模型

### 畸变模型

对于相机坐标系中的一点P，可以通过5个畸变系数$k_1 , k_2, k_3, p_1, p_2$.可以找到这个点在像素平面的正确位置：
1. 将三维空间点$[x, y, z]$投影到归一化的图像平面。设它的归一化坐标为$[\frac{x}{z}, \frac{y}{z}, 1]^T$。
2. 对归一化平面的点计算径向畸变和切向畸变：
$x_{distorted} = x(1 + k_1*r^2 + k_2 *r^4 + k_3 *r^6) + 2p_1xy + p_2(r^2 + 2x^2)$$y_{distorted} = y(1 + k_1*r^2 + k_2 *r^4 + k_3 *r^6) + p_1(r^2 +2y^2) + 2p_2xy$
3. 将畸变后的点通过内参数矩阵投影到像素平面， 得到该点在图像上的正确位置。
	$u = f_x x_{distorted} + c_x$
	$v = f_y y_{distorted} + c_y$

# 第6章 非线性优化

### 状态估计问题
#### 批量状态估计和最大后验估计

在状态估计问题中大致分为两种，一种是**增量式**的，我们应该持有一个当前时刻的估计状态，然后用新得数据更新它。另一种方式是将数据“攒”起来，称为**批量式**的，把0到k时刻的所有数据都放在一起，然后估计得到轨迹地图。

### 实操：曲线拟合

曲线方程： 
$y = exp(ax^2 + bx + c) + w$
其中$a, b, c$ 为曲线参数， $w$为高斯噪声 $w \thicksim (0, \sigma^2)$
我们有$N$个关于$x, y$的观测值，我们想根据这些数据点估计出曲线的参数，可以通过下面的最小二乘问题估计曲线的参数：

$min_{a, b,c} \frac{1}{2} \sum_{i = 1}^{N}\|y_i - exp(ax^2_i + bx_i + c)\|^2$

然后定义误差为 $f(e_i)$：

$e_i = y_i - exp(ax^2_i + bx_i + c)$

然后可以求出每个误差项对于状态变量的导数， 也就是$a, b, c$的偏导数。
$\frac{\partial e_i}{a} = - x_i^2exp(ax^2_i + bx_i + c)$
$\frac{\partial e_i}{b} =- x_iexp(ax^2_i + bx_i + c)$
$\frac{\partial e_i}{c} =-exp(ax^2_i + bx_i + c)$

#### 高斯牛顿法：

#### Ceres求解：

使用Ceres求解最小二乘问题的最优解的一般步骤如下：
1. 构建优化问题的Problem类
2. 构建优化的残差函数CostFunction
3. 最小二乘问题构建，在内次获取到数据后添加残差块
4. 求解最小二乘问题

#### g2o求解：

**简介**： g2o是一个基于图优化的库，图优化是第一种将非线性优化与图论结合起来的理论。
图优化理论：用**顶点**表示**优化变量**，用边表示**误差项**， 然后对于任意一个上述形式的非线性最小二乘的问题可以构建与之对应的图。
如下是一个简单的图优化的例子： 
![[6-3 figure1.png]]
用三角形表示相机位姿节点，圆形表示路标节点，它们构成了图优化的顶点，同时实线表示运动轨迹，虚线表示观测模型，它们构成了边。

## TODO：后面可以添加一个g2o的例子


# 第7章 视觉里程计

#### 特征点
特征点是由关键点（KeyPiont）和描述子（Descriptor）组成，关键点是指该特征点在图像中的位置，描述子通常是一个向量，描述了该关键点周围像素的信息。
一般有ORB、SIFT、SURF，ORB因为实时性比较好才得以广泛应用。
#### 计算相机运动
1. 当相机为单目时，只知道2D的像素坐标，根据**两组2D点**估计运动，该问题用**对级几何**解决。
2. 当相机为双目时、RGB-D时，可以通过某种方法得到距离信息，根据**两组3D点**估计运动，该问题通常用**ICP**解决。
3. 如果**一组为3D点**，另**一组为2D**，即得到了一些3D点和他们在相机的投影位置，也能估计相机的运动，该问题通过**PnP**求解。
#### 2D - 2D: 对极几何

![[7-2 figure1.png]]
其中e1, e2 是极点， l1, l2是极线。
![[7-2 figure2.png]]
对极约束，求得这个公式之后，然后求解E或者F，然后分解出来R，T。

##### 本质矩阵
$x_2^Tt^{\wedge}Rx_1 = 0$
其中$t^{\wedge}R$是E矩阵，x_1, x_2 是匹配点归一化坐标。
通过求解线性方程组：
$(u_2, v_2, 1) \begin{pmatrix}e_1 & e_2 & e_3 \\ e_4 & e_5 & e_6 \\ e_7 & e_8 & e_9 \end{pmatrix} \begin{pmatrix} u_1 \\ v_1 \\ 1 \end{pmatrix} = 0$

可以把E矩阵展开，写成向量的形式：
$e = [e_1, e_2, e_3, e_4, e_5, e_6, e_7, e_8, e_9]$
则对极约束可以写成与e有关的线性形式：
$[u_2u_1, u_2v_1, u_2, v_2u_1, v_2v_1, v_2, u_1, v_1, 1] * e = 0$

对上面这个线性方程组进行SVD分解，会得到关于t和R组合出来的的4个解。将这些解带进去，计算该点在两个相机下的深度值就可以判断解的正确性。![[7-2 figure3.png]]
##### 单应矩阵
描述了两个平面之间的映射关系，若场景中的特征点都落在同一平面，则可以通过单应性进行运动估计在无人机携带的俯视相机或者扫地机携带的顶视相机中比较常见。
通过4对点（不能有3点共线的情况）可以求解出来H，这里的求解过程与求E矩阵的过程类似，也需要进行分解和排除一些解的情况。

单应性在SLAM中具有重要的意义，当特征点共面或者相机发生纯旋转的时候，F矩阵的自由度下降，就会退化，而基础矩阵多出来的自由度则会被噪声所决定，为了避免退化现象造成的影响，通常会同时估计F矩阵和H矩阵，然后选择重投影误差较小的作为最终的运动估计矩阵。

